Test/Api.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Api where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Request
import Test.Response

import Test.Schemas.Package


import Test.Response.ListPackages
import Test.Response.ListPackages

data Api m = Api {
    -- | List all packages
    listPackages ::
        m ListPackagesResponse,
    -- | List all packages
    listPackages ::
        m ListPackagesResponse
}

application :: (Control.Monad.Catch.MonadCatch m, Control.Monad.IO.Class.MonadIO m) => (forall a . Network.Wai.Request -> m a -> IO a) -> Api m -> Network.Wai.Application -> Network.Wai.Application
application run api notFound request respond =
    case Network.Wai.pathInfo request of
        ["packages"] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request (do
                        response <- Control.Monad.Catch.handle pure (listPackages api  )
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                    )
                x ->
                    unsupportedMethod x

        ["packages2"] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request (do
                        response <- Control.Monad.Catch.handle pure (listPackages api  )
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                    )
                x ->
                    unsupportedMethod x

        _ ->
            notFound request respond
    where
        unsupportedMethod _ =
            respond (Network.Wai.responseBuilder (toEnum 405) [] mempty)
---------------------
Test/Request.hs

{-# LANGUAGE OverloadedStrings #-}

module Test.Request
  ( pathVariable,
    requiredQueryParameter,
    optionalQueryParameter,
    parseRequestBodyJSON,
  )
where

import Data.Aeson (FromJSON, parseJSON)
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import Data.Attoparsec.ByteString (eitherResult, parseWith)
import Data.ByteString (ByteString)
import qualified Data.ByteString as ByteString
import qualified Data.List as List
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Encoding as Text
import qualified Network.Wai as Wai
import Web.HttpApiData
  ( FromHttpApiData,
    parseQueryParam,
    parseUrlPiece,
  )

pathVariable ::
  FromHttpApiData a =>
  -- | Path variable value
  Text ->
  (a -> Wai.Application) ->
  Wai.Application
pathVariable value withVariable = \request respond ->
  case parseUrlPiece value of
    Left _err ->
      respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Right x ->
      withVariable x request respond
{-# INLINEABLE pathVariable #-}

requiredQueryParameter ::
  FromHttpApiData a =>
  ByteString ->
  (a -> Wai.Application) ->
  Wai.Application
requiredQueryParameter name withParam = \request respond ->
  case List.lookup name (Wai.queryString request) of
    Nothing ->
      respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Just Nothing ->
      respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Just (Just value) ->
      case parseQueryParam (Text.decodeUtf8 value) of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right x ->
          withParam x request respond
{-# INLINEABLE requiredQueryParameter #-}

optionalQueryParameter ::
  FromHttpApiData a =>
  ByteString ->
  -- | Allow empty, e.g. "x="
  Bool ->
  (Maybe a -> Wai.Application) ->
  Wai.Application
optionalQueryParameter name allowEmpty withParam = \request respond ->
  case List.lookup name (Wai.queryString request) of
    Nothing ->
      withParam Nothing request respond
    Just Nothing
      | allowEmpty ->
        withParam Nothing request respond
      | otherwise ->
        respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Just (Just value) ->
      case parseQueryParam (Text.decodeUtf8 value) of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right x ->
          withParam (Just x) request respond
{-# INLINEABLE optionalQueryParameter #-}

parseRequestBodyJSON :: FromJSON a => (a -> Wai.Application) -> Wai.Application
parseRequestBodyJSON withBody = \request respond ->
  case List.lookup "Content-Type" (Wai.requestHeaders request) of
    Just "application/json" -> do
      result <- parseWith (Wai.getRequestBodyChunk request) Data.Aeson.Parser.json' mempty
      case eitherResult result of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right value ->
          case Data.Aeson.Types.parseEither Data.Aeson.parseJSON value of
            Left _err ->
              respond (Wai.responseBuilder (toEnum 400) [] mempty)
            Right body ->
              withBody body request respond
    _ ->
      respond (Wai.responseBuilder (toEnum 415) [] mempty)
{-# INLINEABLE parseRequestBodyJSON #-}
---------------------
Test/Response.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

class ToResponse a where
    toResponse :: a -> Network.Wai.Response
---------------------
Test/Response/ListPackages.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response.ListPackages where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData



import Test.Response

data ListPackagesResponseBody200
    = ListPackagesResponseBody200A
    | ListPackagesResponseBody200B
    | ListPackagesResponseBody200C
    deriving (Eq, Show)

instance Data.Aeson.ToJSON ListPackagesResponseBody200 where
    toJSON x = case x of
        ListPackagesResponseBody200A -> "A"
        ListPackagesResponseBody200B -> "B"
        ListPackagesResponseBody200C -> "C"

instance Data.Aeson.FromJSON ListPackagesResponseBody200 where
    parseJSON = Data.Aeson.withText "ListPackagesResponseBody200" $ \s ->
        case s of
            "A" -> pure ListPackagesResponseBody200A
            "B" -> pure ListPackagesResponseBody200B
            "C" -> pure ListPackagesResponseBody200C
            _ -> fail "invalid enum value"

data ListPackagesResponse
    = ListPackagesResponse200 ListPackagesResponseBody200 
    deriving (Show)

instance Control.Exception.Exception ListPackagesResponse

instance ToResponse ListPackagesResponse where
    toResponse (ListPackagesResponse200 x ) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
Test/Response/ListPackages.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response.ListPackages where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Package

import Test.Response



data ListPackagesResponse
    = ListPackagesResponse200 Package 
    deriving (Show)

instance Control.Exception.Exception ListPackagesResponse

instance ToResponse ListPackagesResponse where
    toResponse (ListPackagesResponse200 x ) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
Test/Schemas/Package.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Package where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData





data Package
    = PackageDOCKER
    | PackagePYTHON
    | PackageNPM
    deriving (Eq, Show)

instance Data.Aeson.ToJSON Package where
    toJSON x = case x of
        PackageDOCKER -> "DOCKER"
        PackagePYTHON -> "PYTHON"
        PackageNPM -> "NPM"

instance Data.Aeson.FromJSON Package where
    parseJSON = Data.Aeson.withText "Package" $ \s ->
        case s of
            "DOCKER" -> pure PackageDOCKER
            "PYTHON" -> pure PackagePYTHON
            "NPM" -> pure PackageNPM
            _ -> fail "invalid enum value"
---------------------
test.cabal

cabal-version: 3.0
name: test
version: 0.1.0.0
library
  build-depends:
    , aeson
    , attoparsec
    , base
    , bytestring
    , exceptions
    , ghc-prim
    , http-api-data
    , http-types
    , text
    , time
    , wai
  exposed-modules:
    Test.Api
    Test.Request
    Test.Response
    Test.Response.ListPackages
    Test.Schemas.Package