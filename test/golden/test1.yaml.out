Test/Api.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Api where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Request
import Test.Response

import Test.Schemas.Vehicle
import Test.Schemas.NISE

import Test.Response.GetUser
import Test.Response.CreateUser

data Api m = Api {
    getUser ::
        -- @id@ Uniquely identifies a user
        GHC.Int.Int ->
        -- @name@ Name of a user
        Data.Text.Text ->
        -- @page@
        GHC.Int.Int ->
        -- @offset@
        (Data.Maybe.Maybe (GHC.Int.Int)) ->
        m GetUserResponse,
    -- | Adds a new user
    createUser ::
        -- @id@ Uniquely identifies a user
        GHC.Int.Int ->
        -- @name@ Name of a user
        Data.Text.Text ->
        -- @page@
        GHC.Int.Int ->
        -- @offset@
        (Data.Maybe.Maybe (GHC.Int.Int)) ->
        -- Some nice request body
        CreateUserRequestBody ->
        m CreateUserResponse
}

application :: (Control.Monad.Catch.MonadCatch m, Control.Monad.IO.Class.MonadIO m) => (forall a . Network.Wai.Request -> m a -> IO a) -> Api m -> Network.Wai.Application -> Network.Wai.Application
application run api notFound request respond =
    case Network.Wai.pathInfo request of
        ["users", __id, "create", __name] ->
            pathVariable __id (\__id request respond ->
                pathVariable __name (\__name request respond ->
                    case Network.Wai.requestMethod request of
                        "POST" ->
                            requiredQueryParameter "page" (\__page request respond ->
                                optionalQueryParameter "offset" False (\__offset request respond ->
                                    parseRequestBodyJSON (\body request respond ->
                                        run request (do
                                            response <- Control.Monad.Catch.handle pure (createUser api __id __name __page __offset body)
                                            Control.Monad.IO.Class.liftIO (respond $! (toResponse response))
                                        )) request respond) request respond) request respond
                        "GET" ->
                            requiredQueryParameter "page" (\__page request respond ->
                                optionalQueryParameter "offset" False (\__offset request respond ->
                                    run request (do
                                        response <- Control.Monad.Catch.handle pure (getUser api __id __name __page __offset )
                                        Control.Monad.IO.Class.liftIO (respond $! (toResponse response))
                                    )) request respond) request respond
                        x ->
                            unsupportedMethod x) request respond) request respond

        _ ->
            notFound request respond
    where
        unsupportedMethod _ =
            respond (Network.Wai.responseBuilder (toEnum 405) [] mempty)
---------------------
Test/Request.hs

{-# LANGUAGE OverloadedStrings #-}

module Test.Request
  ( pathVariable,
    requiredQueryParameter,
    optionalQueryParameter,
    requiredHeader,
    optionalHeader,
    parseRequestBodyJSON,
  )
where

import Data.Aeson (FromJSON, parseJSON)
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import Data.Attoparsec.ByteString (eitherResult, parseWith)
import Data.ByteString (ByteString)
import qualified Data.ByteString as ByteString
import qualified Data.List as List
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Encoding as Text
import Network.HTTP.Types (HeaderName, hContentType)
import qualified Network.Wai as Wai
import Web.HttpApiData
  ( FromHttpApiData,
    parseHeader,
    parseQueryParam,
    parseUrlPiece,
  )

pathVariable ::
  FromHttpApiData a =>
  -- | Path variable value
  Text ->
  (a -> Wai.Application) ->
  Wai.Application
pathVariable value withVariable = \request respond ->
  case parseUrlPiece value of
    Left _err ->
      respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Right x ->
      withVariable x request respond
{-# INLINEABLE pathVariable #-}

requiredQueryParameter ::
  FromHttpApiData a =>
  ByteString ->
  (a -> Wai.Application) ->
  Wai.Application
requiredQueryParameter name withParam = \request respond ->
  case List.lookup name (Wai.queryString request) of
    Nothing ->
      respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Just Nothing ->
      respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Just (Just value) ->
      case parseQueryParam (Text.decodeUtf8 value) of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right x ->
          withParam x request respond
{-# INLINEABLE requiredQueryParameter #-}

optionalQueryParameter ::
  FromHttpApiData a =>
  ByteString ->
  -- | Allow empty, e.g. "x="
  Bool ->
  (Maybe a -> Wai.Application) ->
  Wai.Application
optionalQueryParameter name allowEmpty withParam = \request respond ->
  case List.lookup name (Wai.queryString request) of
    Nothing ->
      withParam Nothing request respond
    Just Nothing
      | allowEmpty ->
        withParam Nothing request respond
      | otherwise ->
        respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Just (Just value) ->
      case parseQueryParam (Text.decodeUtf8 value) of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right x ->
          withParam (Just x) request respond
{-# INLINEABLE optionalQueryParameter #-}

optionalHeader ::
  FromHttpApiData a =>
  HeaderName ->
  (Maybe a -> Wai.Application) ->
  Wai.Application
optionalHeader name withHeader = \request respond ->
  case List.lookup name (Wai.requestHeaders request) of
    Nothing ->
      withHeader Nothing request respond
    Just value ->
      case parseHeader value of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right x ->
          withHeader (Just x) request respond
{-# INLINEABLE optionalHeader #-}

requiredHeader ::
  FromHttpApiData a =>
  HeaderName ->
  (a -> Wai.Application) ->
  Wai.Application
requiredHeader name withHeader = \request respond ->
  case List.lookup name (Wai.requestHeaders request) of
    Nothing ->
      respond (Wai.responseBuilder (toEnum 400) [] mempty)
    Just value ->
      case parseHeader value of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right x ->
          withHeader x request respond
{-# INLINEABLE requiredHeader #-}

parseRequestBodyJSON :: FromJSON a => (a -> Wai.Application) -> Wai.Application
parseRequestBodyJSON withBody = \request respond ->
  case List.lookup hContentType (Wai.requestHeaders request) of
    Just "application/json" -> do
      result <- parseWith (Wai.getRequestBodyChunk request) Data.Aeson.Parser.json' mempty
      case eitherResult result of
        Left _err ->
          respond (Wai.responseBuilder (toEnum 400) [] mempty)
        Right value ->
          case Data.Aeson.Types.parseEither Data.Aeson.parseJSON value of
            Left _err ->
              respond (Wai.responseBuilder (toEnum 400) [] mempty)
            Right body ->
              withBody body request respond
    _ ->
      respond (Wai.responseBuilder (toEnum 415) [] mempty)
{-# INLINEABLE parseRequestBodyJSON #-}

---------------------
Test/Response.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

class ToResponse a where
    toResponse :: a -> Network.Wai.Response
---------------------
Test/Response/CreateUser.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response.CreateUser where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.NISE

import Test.Response

newtype CreateUserRequestBody = CreateUserRequestBody
    {
        nise :: (Data.Maybe.Maybe (NISE))
    }
    deriving (Show)

instance Data.Aeson.ToJSON CreateUserRequestBody where
    toJSON CreateUserRequestBody {..} = Data.Aeson.object
        [
            "nise" Data.Aeson..= nise
        ]

instance Data.Aeson.FromJSON CreateUserRequestBody where
    parseJSON = Data.Aeson.withObject "CreateUserRequestBody" $ \o ->
        CreateUserRequestBody
            <$> o Data.Aeson..:? "nise"
newtype CreateUserResponseBody200 = CreateUserResponseBody200
    {
        name :: (Data.Maybe.Maybe (Data.Text.Text))
    }
    deriving (Show)

instance Data.Aeson.ToJSON CreateUserResponseBody200 where
    toJSON CreateUserResponseBody200 {..} = Data.Aeson.object
        [
            "name" Data.Aeson..= name
        ]

instance Data.Aeson.FromJSON CreateUserResponseBody200 where
    parseJSON = Data.Aeson.withObject "CreateUserResponseBody200" $ \o ->
        CreateUserResponseBody200
            <$> o Data.Aeson..:? "name"

data CreateUserResponse
    = CreateUserResponse200 CreateUserResponseBody200 
    deriving (Show)

instance Control.Exception.Exception CreateUserResponse

instance ToResponse CreateUserResponse where
    toResponse (CreateUserResponse200 x ) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
Test/Response/GetUser.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response.GetUser where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Vehicle

import Test.Response



data GetUserResponse
    = GetUserResponse200 Vehicle 
    deriving (Show)

instance Control.Exception.Exception GetUserResponse

instance ToResponse GetUserResponse where
    toResponse (GetUserResponse200 x ) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
Test/Schemas/Car.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Car where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Vehicle



data Car = Car
    {
        has_4_wheel_drive :: (Data.Maybe.Maybe (GHC.Types.Bool)),
        id :: GHC.Int.Int,
        model :: (Data.Maybe.Maybe (Data.Text.Text)),
        name :: (Data.Maybe.Maybe (Data.Text.Text)),
        type' :: Data.Text.Text
    }
    deriving (Show)

instance Data.Aeson.ToJSON Car where
    toJSON Car {..} = Data.Aeson.object
        [
            "has_4_wheel_drive" Data.Aeson..= has_4_wheel_drive,
            "id" Data.Aeson..= id,
            "model" Data.Aeson..= model,
            "name" Data.Aeson..= name,
            "type" Data.Aeson..= type'
        ]

instance Data.Aeson.FromJSON Car where
    parseJSON = Data.Aeson.withObject "Car" $ \o ->
        Car
            <$> o Data.Aeson..:? "has_4_wheel_drive"
            <*> o Data.Aeson..: "id"
            <*> o Data.Aeson..:? "model"
            <*> o Data.Aeson..:? "name"
            <*> o Data.Aeson..: "type"
---------------------
Test/Schemas/NISE.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.NISE where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.PackageId

newtype NISEValue = NISEValue
    {
        name :: (Data.Maybe.Maybe (Data.Text.Text))
    }
    deriving (Show)

instance Data.Aeson.ToJSON NISEValue where
    toJSON NISEValue {..} = Data.Aeson.object
        [
            "name" Data.Aeson..= name
        ]

instance Data.Aeson.FromJSON NISEValue where
    parseJSON = Data.Aeson.withObject "NISEValue" $ \o ->
        NISEValue
            <$> o Data.Aeson..:? "name"

data NISE = NISE
    {
        description :: PackageId,
        id :: GHC.Int.Int64,
        name :: Data.Text.Text,
        ports :: [ GHC.Int.Int ],
        value :: (Data.Maybe.Maybe (NISEValue))
    }
    deriving (Show)

instance Data.Aeson.ToJSON NISE where
    toJSON NISE {..} = Data.Aeson.object
        [
            "description" Data.Aeson..= description,
            "id" Data.Aeson..= id,
            "name" Data.Aeson..= name,
            "ports" Data.Aeson..= ports,
            "value" Data.Aeson..= value
        ]

instance Data.Aeson.FromJSON NISE where
    parseJSON = Data.Aeson.withObject "NISE" $ \o ->
        NISE
            <$> o Data.Aeson..: "description"
            <*> o Data.Aeson..: "id"
            <*> o Data.Aeson..: "name"
            <*> o Data.Aeson..: "ports"
            <*> o Data.Aeson..:? "value"
---------------------
Test/Schemas/PackageId.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.PackageId where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Car
import Test.Schemas.Plane

data PackageIdOneOf4 = PackageIdOneOf4
    {
        age :: (Data.Maybe.Maybe (GHC.Int.Int)),
        enum :: PackageIdOneOf4Enum,
        list :: (Data.Maybe.Maybe ([ PackageIdOneOf4List ])),
        name :: Data.Text.Text
    }
    deriving (Show)

instance Data.Aeson.ToJSON PackageIdOneOf4 where
    toJSON PackageIdOneOf4 {..} = Data.Aeson.object
        [
            "age" Data.Aeson..= age,
            "enum" Data.Aeson..= enum,
            "list" Data.Aeson..= list,
            "name" Data.Aeson..= name
        ]

instance Data.Aeson.FromJSON PackageIdOneOf4 where
    parseJSON = Data.Aeson.withObject "PackageIdOneOf4" $ \o ->
        PackageIdOneOf4
            <$> o Data.Aeson..:? "age"
            <*> o Data.Aeson..: "enum"
            <*> o Data.Aeson..:? "list"
            <*> o Data.Aeson..: "name"

data PackageIdOneOf4Enum
    = PackageIdOneOf4EnumA
    | PackageIdOneOf4EnumB
    deriving (Eq, Show)

instance Data.Aeson.ToJSON PackageIdOneOf4Enum where
    toJSON x = case x of
        PackageIdOneOf4EnumA -> "A"
        PackageIdOneOf4EnumB -> "B"

instance Data.Aeson.FromJSON PackageIdOneOf4Enum where
    parseJSON = Data.Aeson.withText "PackageIdOneOf4Enum" $ \s ->
        case s of
            "A" -> pure PackageIdOneOf4EnumA
            "B" -> pure PackageIdOneOf4EnumB
            _ -> fail "invalid enum value"

newtype PackageIdOneOf4List = PackageIdOneOf4List
    {
        cool :: (Data.Maybe.Maybe (Data.Text.Text))
    }
    deriving (Show)

instance Data.Aeson.ToJSON PackageIdOneOf4List where
    toJSON PackageIdOneOf4List {..} = Data.Aeson.object
        [
            "cool" Data.Aeson..= cool
        ]

instance Data.Aeson.FromJSON PackageIdOneOf4List where
    parseJSON = Data.Aeson.withObject "PackageIdOneOf4List" $ \o ->
        PackageIdOneOf4List
            <$> o Data.Aeson..:? "cool"

data PackageId
    = PackageIdPlane Plane
    | PackageIdCar Car
    | PackageIdPackageIdOneOf3 GHC.Int.Int
    | PackageIdPackageIdOneOf4 PackageIdOneOf4
    deriving (Show)

instance Data.Aeson.ToJSON PackageId where
    toJSON (PackageIdPlane x) = Data.Aeson.toJSON x
    toJSON (PackageIdCar x) = Data.Aeson.toJSON x
    toJSON (PackageIdPackageIdOneOf3 x) = Data.Aeson.toJSON x
    toJSON (PackageIdPackageIdOneOf4 x) = Data.Aeson.toJSON x

instance Data.Aeson.FromJSON PackageId where
    parseJSON x =
        (PackageIdPlane <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (PackageIdCar <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (PackageIdPackageIdOneOf3 <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (PackageIdPackageIdOneOf4 <$> Data.Aeson.parseJSON x)
---------------------
Test/Schemas/Plane.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Plane where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Car
import Test.Schemas.Vehicle



data Plane = Plane
    {
        car :: (Data.Maybe.Maybe (Car)),
        has_reactor :: (Data.Maybe.Maybe (GHC.Types.Bool)),
        id :: (Data.Maybe.Maybe (GHC.Int.Int)),
        model :: (Data.Maybe.Maybe (Data.Text.Text)),
        name :: (Data.Maybe.Maybe (Data.Text.Text)),
        nb_passengers :: (Data.Maybe.Maybe (GHC.Int.Int)),
        type' :: (Data.Maybe.Maybe (Data.Text.Text))
    }
    deriving (Show)

instance Data.Aeson.ToJSON Plane where
    toJSON Plane {..} = Data.Aeson.object
        [
            "car" Data.Aeson..= car,
            "has_reactor" Data.Aeson..= has_reactor,
            "id" Data.Aeson..= id,
            "model" Data.Aeson..= model,
            "name" Data.Aeson..= name,
            "nb_passengers" Data.Aeson..= nb_passengers,
            "type" Data.Aeson..= type'
        ]

instance Data.Aeson.FromJSON Plane where
    parseJSON = Data.Aeson.withObject "Plane" $ \o ->
        Plane
            <$> o Data.Aeson..:? "car"
            <*> o Data.Aeson..:? "has_reactor"
            <*> o Data.Aeson..:? "id"
            <*> o Data.Aeson..:? "model"
            <*> o Data.Aeson..:? "name"
            <*> o Data.Aeson..:? "nb_passengers"
            <*> o Data.Aeson..:? "type"
---------------------
Test/Schemas/Vehicle.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Vehicle where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Float
import qualified GHC.Int
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData





data Vehicle = Vehicle
    {
        id :: GHC.Int.Int,
        model :: (Data.Maybe.Maybe (Data.Text.Text)),
        name :: (Data.Maybe.Maybe (Data.Text.Text)),
        type' :: Data.Text.Text
    }
    deriving (Show)

instance Data.Aeson.ToJSON Vehicle where
    toJSON Vehicle {..} = Data.Aeson.object
        [
            "id" Data.Aeson..= id,
            "model" Data.Aeson..= model,
            "name" Data.Aeson..= name,
            "type" Data.Aeson..= type'
        ]

instance Data.Aeson.FromJSON Vehicle where
    parseJSON = Data.Aeson.withObject "Vehicle" $ \o ->
        Vehicle
            <$> o Data.Aeson..: "id"
            <*> o Data.Aeson..:? "model"
            <*> o Data.Aeson..:? "name"
            <*> o Data.Aeson..: "type"
---------------------
test.cabal

cabal-version: 3.0
name: test
version: 0.1.0.0
library
  build-depends:
    , aeson
    , attoparsec
    , base
    , bytestring
    , exceptions
    , ghc-prim
    , http-api-data
    , http-types
    , text
    , time
    , wai
  exposed-modules:
    Test.Api
    Test.Request
    Test.Response
    Test.Response.CreateUser
    Test.Response.GetUser
    Test.Schemas.Car
    Test.Schemas.NISE
    Test.Schemas.PackageId
    Test.Schemas.Plane
    Test.Schemas.Vehicle