Test/Api.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Api where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Response

import Test.Schemas.Packages
import Test.Schemas.Inline2
import Test.Schemas.Inline

import Test.Response.ListPackages
import Test.Response.ListPackages2
import Test.Response.ListPackages2

data Api m = Api {
    -- | List all packages
    listPackages ::
        m ListPackagesResponse,
    -- | List all packages
    listPackages2 ::
        m ListPackages2Response,
    -- | List all packages
    listPackages2 ::
        m ListPackages2Response
}

application :: (Control.Monad.Catch.MonadCatch m, Control.Monad.IO.Class.MonadIO m) => (forall a . Network.Wai.Request -> m a -> IO a) -> Api m -> Network.Wai.Application -> Network.Wai.Application
application run api notFound request respond =
    case Network.Wai.pathInfo request of
        [ "packages" ] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request $ do
                        response <- Control.Monad.Catch.handle pure $ listPackages api  
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                x ->
                    unsupportedMethod x

        [ "packages2" ] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request $ do
                        response <- Control.Monad.Catch.handle pure $ listPackages2 api  
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                x ->
                    unsupportedMethod x

        [ "packages3" ] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request $ do
                        response <- Control.Monad.Catch.handle pure $ listPackages2 api  
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                x ->
                    unsupportedMethod x

        _ ->
            notFound request respond
    where
        unsupportedMethod _ =
            respond (Network.Wai.responseBuilder (toEnum 405) [] mempty)
        invalidRequest _ =
            respond (Network.Wai.responseBuilder (toEnum 401) [] mempty)
---------------------
Test/Response.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

class ToResponse a where
    toResponse :: a -> Network.Wai.Response
---------------------
Test/Response/ListPackages.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response.ListPackages where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Packages

import Test.Response



data ListPackagesResponse
    = ListPackagesResponse200 Packages
    deriving (Show)

instance Control.Exception.Exception ListPackagesResponse

instance ToResponse ListPackagesResponse where
    toResponse (ListPackagesResponse200 x) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
Test/Response/ListPackages2.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response.ListPackages2 where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Inline

import Test.Response



data ListPackages2Response
    = ListPackages2Response200 Inline
    deriving (Show)

instance Control.Exception.Exception ListPackages2Response

instance ToResponse ListPackages2Response where
    toResponse (ListPackages2Response200 x) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
Test/Response/ListPackages2.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Response.ListPackages2 where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Inline2

import Test.Response



data ListPackages2Response
    = ListPackages2Response200 Inline2
    deriving (Show)

instance Control.Exception.Exception ListPackages2Response

instance ToResponse ListPackages2Response where
    toResponse (ListPackages2Response200 x) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
Test/Schemas/Inline.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Inline where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Package

data InlineValue
    = InlineValueInlineValueOneOf1 GHC.Types.Int
    | InlineValueInlineValueOneOf2 Data.Text.Text
    | InlineValuePackage Package
    deriving (Show)

instance Data.Aeson.ToJSON InlineValue where
    toJSON (InlineValueInlineValueOneOf1 x) = Data.Aeson.toJSON x
    toJSON (InlineValueInlineValueOneOf2 x) = Data.Aeson.toJSON x
    toJSON (InlineValuePackage x) = Data.Aeson.toJSON x

instance Data.Aeson.FromJSON InlineValue where
    parseJSON x =
        (InlineValueInlineValueOneOf1 <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (InlineValueInlineValueOneOf2 <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (InlineValuePackage <$> Data.Aeson.parseJSON x)

newtype Inline = Inline
    {
        value :: Data.Maybe.Maybe (InlineValue)
    }
    deriving (Show)

instance Data.Aeson.ToJSON Inline where
    toJSON Inline {..} = Data.Aeson.object
        [
            "value" Data.Aeson..= value
        ]

instance Data.Aeson.FromJSON Inline where
    parseJSON = Data.Aeson.withObject "Inline" $ \o ->
        Inline
            <$> o Data.Aeson..:? "value"
---------------------
Test/Schemas/Inline2.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Inline2 where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Package

data Inline2Value
    = Inline2ValueInline2ValueOneOf1 GHC.Types.Int
    | Inline2ValueInline2ValueOneOf2 Data.Text.Text
    | Inline2ValueInline2ValueOneOf3 Inline2ValueOneOf3
    deriving (Show)

instance Data.Aeson.ToJSON Inline2Value where
    toJSON (Inline2ValueInline2ValueOneOf1 x) = Data.Aeson.toJSON x
    toJSON (Inline2ValueInline2ValueOneOf2 x) = Data.Aeson.toJSON x
    toJSON (Inline2ValueInline2ValueOneOf3 x) = Data.Aeson.toJSON x

instance Data.Aeson.FromJSON Inline2Value where
    parseJSON x =
        (Inline2ValueInline2ValueOneOf1 <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (Inline2ValueInline2ValueOneOf2 <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (Inline2ValueInline2ValueOneOf3 <$> Data.Aeson.parseJSON x)

data Inline2ValueOneOf3
    = Inline2ValueOneOf3Inline2ValueOneOf3OneOf1 GHC.Types.Double
    | Inline2ValueOneOf3Package Package
    deriving (Show)

instance Data.Aeson.ToJSON Inline2ValueOneOf3 where
    toJSON (Inline2ValueOneOf3Inline2ValueOneOf3OneOf1 x) = Data.Aeson.toJSON x
    toJSON (Inline2ValueOneOf3Package x) = Data.Aeson.toJSON x

instance Data.Aeson.FromJSON Inline2ValueOneOf3 where
    parseJSON x =
        (Inline2ValueOneOf3Inline2ValueOneOf3OneOf1 <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (Inline2ValueOneOf3Package <$> Data.Aeson.parseJSON x)

newtype Inline2 = Inline2
    {
        value :: Data.Maybe.Maybe (Inline2Value)
    }
    deriving (Show)

instance Data.Aeson.ToJSON Inline2 where
    toJSON Inline2 {..} = Data.Aeson.object
        [
            "value" Data.Aeson..= value
        ]

instance Data.Aeson.FromJSON Inline2 where
    parseJSON = Data.Aeson.withObject "Inline2" $ \o ->
        Inline2
            <$> o Data.Aeson..:? "value"
---------------------
Test/Schemas/Package.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Package where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData





newtype Package = Package
    {
        name :: Data.Maybe.Maybe (Data.Text.Text)
    }
    deriving (Show)

instance Data.Aeson.ToJSON Package where
    toJSON Package {..} = Data.Aeson.object
        [
            "name" Data.Aeson..= name
        ]

instance Data.Aeson.FromJSON Package where
    parseJSON = Data.Aeson.withObject "Package" $ \o ->
        Package
            <$> o Data.Aeson..:? "name"
---------------------
Test/Schemas/Packages.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module Test.Schemas.Packages where

import qualified Control.Applicative
import qualified Control.Exception
import qualified Control.Monad
import qualified Control.Monad.Catch
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import Test.Schemas.Package



data Packages
    = PackagesPackage Package
    | PackagesPackage Package
    deriving (Show)

instance Data.Aeson.ToJSON Packages where
    toJSON (PackagesPackage x) = Data.Aeson.toJSON x
    toJSON (PackagesPackage x) = Data.Aeson.toJSON x

instance Data.Aeson.FromJSON Packages where
    parseJSON x =
        (PackagesPackage <$> Data.Aeson.parseJSON x) Control.Applicative.<|>
        (PackagesPackage <$> Data.Aeson.parseJSON x)
---------------------
test.cabal

cabal-version: 3.0
name: test
version: 0.1.0.0
library
  build-depends:
    , aeson
    , attoparsec
    , base
    , exceptions
    , ghc-prim
    , http-api-data
    , http-types
    , text
    , time
    , wai
  exposed-modules:
    Test.Api
    Test.Response
    Test.Response.ListPackages
    Test.Response.ListPackages2
    Test.Schemas.Inline
    Test.Schemas.Inline2
    Test.Schemas.Package
    Test.Schemas.Packages