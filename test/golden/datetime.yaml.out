OpenAPI/Api.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Api where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import OpenAPI.Response

import OpenAPI.Schemas.Test

import OpenAPI.Response.Test

data Api m = Api {
    test :: m TestResponse
}

application :: (Control.Monad.IO.Class.MonadIO m) => (forall a . Network.Wai.Request -> m a -> IO a) -> Api m -> Network.Wai.Application -> Network.Wai.Application
application run api notFound request respond =
    case Network.Wai.pathInfo request of
        [ "test" ] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request $ do
                        response <- test api  
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                x ->
                    unsupportedMethod x

        _ ->
            notFound request respond
    where
        unsupportedMethod _ =
            respond (Network.Wai.responseBuilder (toEnum 405) [] mempty)
        invalidRequest _ =
            respond (Network.Wai.responseBuilder (toEnum 401) [] mempty)
---------------------
OpenAPI/Response.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Response where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

class ToResponse a where
    toResponse :: a -> Network.Wai.Response
---------------------
OpenAPI/Response/Test.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Response.Test where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import OpenAPI.Schemas.Test

import OpenAPI.Response

data TestResponse
    = TestResponse200 Test

instance ToResponse TestResponse where
    toResponse (TestResponse200 x) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
OpenAPI/Schemas/Test.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Schemas.Test where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData





data Test = Test
    {
        dateProp :: Data.Maybe.Maybe (Data.Time.Day),
        dateTimeProp :: Data.Maybe.Maybe (Data.Time.UTCTime)
    }

instance Data.Aeson.ToJSON Test where
    toJSON Test {..} = Data.Aeson.object
        [
            "dateProp" Data.Aeson..= dateProp,
            "dateTimeProp" Data.Aeson..= dateTimeProp
        ]

instance Data.Aeson.FromJSON Test where
    parseJSON = Data.Aeson.withObject "Test" $ \o ->
        Test
            <$> o Data.Aeson..:? "dateProp"
            <*> o Data.Aeson..:? "dateTimeProp"
---------------------
open-api.cabal

cabal-version: 3.0
name: open-api
version: 0.1.0.0
library
  build-depends:
    , aeson
    , attoparsec
    , base
    , ghc-prim
    , http-api-data
    , http-types
    , text
    , wai
  exposed-modules:
    OpenAPI.Api
    OpenAPI.Response
    OpenAPI.Response.Test
    OpenAPI.Schemas.Test