OpenAPI/Api.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Api where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import OpenAPI.Response

import OpenAPI.Schemas.Packages
import OpenAPI.Schemas.Inline
import OpenAPI.Schemas.Package

import OpenAPI.Response.ListPackages
import OpenAPI.Response.ListPackages3
import OpenAPI.Response.ListPackages2

data Api m = Api {
    -- | List all packages
    listPackages ::
        m ListPackagesResponse,
    -- | List all packages
    listPackages3 ::
        m ListPackages3Response,
    -- | List all packages
    listPackages2 ::
        m ListPackages2Response
}

application :: (Control.Monad.IO.Class.MonadIO m) => (forall a . Network.Wai.Request -> m a -> IO a) -> Api m -> Network.Wai.Application -> Network.Wai.Application
application run api notFound request respond =
    case Network.Wai.pathInfo request of
        [ "packages" ] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request $ do
                        response <- listPackages api  
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                x ->
                    unsupportedMethod x

        [ "packages2" ] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request $ do
                        response <- listPackages2 api  
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                x ->
                    unsupportedMethod x

        [ "packages3" ] ->
            case Network.Wai.requestMethod request of
                "GET" ->
                    run request $ do
                        response <- listPackages3 api  
                        Control.Monad.IO.Class.liftIO (respond (toResponse response))
                x ->
                    unsupportedMethod x

        _ ->
            notFound request respond
    where
        unsupportedMethod _ =
            respond (Network.Wai.responseBuilder (toEnum 405) [] mempty)
        invalidRequest _ =
            respond (Network.Wai.responseBuilder (toEnum 401) [] mempty)
---------------------
OpenAPI/Response.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Response where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

class ToResponse a where
    toResponse :: a -> Network.Wai.Response
---------------------
OpenAPI/Response/ListPackages.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Response.ListPackages where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import OpenAPI.Schemas.Packages

import OpenAPI.Response

data ListPackagesResponse
    = ListPackagesResponse200 Packages

instance ToResponse ListPackagesResponse where
    toResponse (ListPackagesResponse200 x) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
OpenAPI/Response/ListPackages2.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Response.ListPackages2 where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import OpenAPI.Schemas.Package

import OpenAPI.Response

data ListPackages2Response
    = ListPackages2Response200 [ Package ]

instance ToResponse ListPackages2Response where
    toResponse (ListPackages2Response200 x) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
OpenAPI/Response/ListPackages3.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Response.ListPackages3 where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import OpenAPI.Schemas.Inline

import OpenAPI.Response

data ListPackages3Response
    = ListPackages3Response200 [ Inline ]

instance ToResponse ListPackages3Response where
    toResponse (ListPackages3Response200 x) =
        Network.Wai.responseBuilder (toEnum 200) [(Network.HTTP.Types.hContentType, "application/json")] (Data.Aeson.fromEncoding (Data.Aeson.toEncoding x))
---------------------
OpenAPI/Schemas/Inline.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Schemas.Inline where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData



newtype InlineElem = InlineElem
    {
        name :: Data.Maybe.Maybe (Data.Text.Text)
    }

instance Data.Aeson.ToJSON InlineElem where
    toJSON InlineElem {..} = Data.Aeson.object
        [
            "name" Data.Aeson..= name
        ]

instance Data.Aeson.FromJSON InlineElem where
    parseJSON = Data.Aeson.withObject "InlineElem" $ \o ->
        InlineElem
            <$> o Data.Aeson..:? "name"

type Inline = [ InlineElem ]
---------------------
OpenAPI/Schemas/Package.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Schemas.Package where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData





newtype Package = Package
    {
        name :: Data.Maybe.Maybe (Data.Text.Text)
    }

instance Data.Aeson.ToJSON Package where
    toJSON Package {..} = Data.Aeson.object
        [
            "name" Data.Aeson..= name
        ]

instance Data.Aeson.FromJSON Package where
    parseJSON = Data.Aeson.withObject "Package" $ \o ->
        Package
            <$> o Data.Aeson..:? "name"
---------------------
OpenAPI/Schemas/Packages.hs

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
module OpenAPI.Schemas.Packages where

import qualified Control.Applicative
import qualified Control.Monad
import qualified Control.Monad.IO.Class
import qualified Data.Aeson
import qualified Data.Aeson.Parser
import qualified Data.Aeson.Types
import qualified Data.Attoparsec.ByteString
import qualified Data.List
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Time
import qualified Data.Text.Encoding
import qualified GHC.Types
import qualified Network.HTTP.Types
import qualified Network.Wai
import qualified Web.HttpApiData

import OpenAPI.Schemas.Package



type Packages = [ Package ]
---------------------
open-api.cabal

cabal-version: 3.0
name: open-api
version: 0.1.0.0
library
  build-depends:
    , aeson
    , attoparsec
    , base
    , ghc-prim
    , http-api-data
    , http-types
    , text
    , wai
  exposed-modules:
    OpenAPI.Api
    OpenAPI.Response
    OpenAPI.Response.ListPackages
    OpenAPI.Response.ListPackages2
    OpenAPI.Response.ListPackages3
    OpenAPI.Schemas.Inline
    OpenAPI.Schemas.Package
    OpenAPI.Schemas.Packages